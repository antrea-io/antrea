// Copyright 2021 Antrea Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package clusteruuid

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/wait"
	clientset "k8s.io/client-go/kubernetes"
	"k8s.io/klog"
)

const (
	DefaultUUIDConfigMapName = "antrea-cluster-uuid"
	uuidConfigMapKey         = "uuid"
)

// ClusterUUIDAllocator is used to ensure that a cluster UUID has been allocated, i.e. stored in the
// antrea-cluster-uuid ConfigMap. It is meant to be used by the Antrea Controller.
type ClusterUUIDAllocator struct {
	uuidConfigMapNamespace string
	uuidConfigMapName      string
	k8sClient              clientset.Interface
}

// NewClusterUUIDAllocator creates a ClusterUUIDAllocator object.
func NewClusterUUIDAllocator(
	uuidConfigMapNamespace string,
	uuidConfigMapName string,
	k8sClient clientset.Interface,
) ClusterUUIDAllocator {
	return ClusterUUIDAllocator{
		uuidConfigMapNamespace: uuidConfigMapNamespace,
		uuidConfigMapName:      uuidConfigMapName,
		k8sClient:              k8sClient,
	}
}

// Run will ensure that a correct cluster UUID has been allocated, i.e. stored in the
// antrea-cluster-uuid ConfigMap. It is meant to be called asynchronously in its own goroutine, and
// will keep retrying in case of error, using an exponential backoff mechanism If a cluster UUID
// already exists and is valid, Run is essentially a no-op. Otherwise, Run will create a new UUID
// and store it in the ConfigMap..
func (a ClusterUUIDAllocator) Run(stopCh <-chan struct{}) {
	allocateClusterUUIDIfNeeded := func() error {
		configMap, err := a.k8sClient.CoreV1().ConfigMaps(a.uuidConfigMapNamespace).Get(context.TODO(), a.uuidConfigMapName, metav1.GetOptions{})
		if err != nil {
			return fmt.Errorf("error when getting '%s/%s' ConfigMap: %v", a.uuidConfigMapNamespace, a.uuidConfigMapName, err)
		}
		clusterUUIDStr, ok := configMap.Data[uuidConfigMapKey]
		if ok && clusterUUIDStr != "" {
			if clusterUUID, err := uuid.Parse(clusterUUIDStr); err != nil {
				klog.Errorf("Cluster already has UUID but it cannot be parsed, generating a new one")
			} else {
				klog.Infof("Exiting cluster UUID: %v", clusterUUID)
				return nil
			}
		}

		// need to generate cluster UUID
		clusterUUID := uuid.New()
		configMap.Data = map[string]string{uuidConfigMapKey: clusterUUID.String()}
		if _, err := a.k8sClient.CoreV1().ConfigMaps(a.uuidConfigMapNamespace).Update(context.TODO(), configMap, metav1.UpdateOptions{}); err != nil {
			return fmt.Errorf("error when updating '%s/%s' ConfigMap with new cluster UUID: %v", a.uuidConfigMapNamespace, a.uuidConfigMapName, err)
		}

		klog.Infof("New cluster UUID: %v", clusterUUID)
		return nil
	}

	// exponential backoff, starting at 100ms with a factor of 2. A "steps" value of 10 means we
	// will increase the backoff duration at most 10 times, so the max duration is (100ms * //
	// 2^8), which is about 25s.
	retry := wait.Backoff{
		Steps:    8,
		Duration: 100 * time.Millisecond,
		Factor:   2.0,
		Jitter:   0.0,
	}

	for {
		err := allocateClusterUUIDIfNeeded()
		if err == nil {
			return
		}
		sleepDuration := retry.Step()
		klog.Errorf("Cannot validate or update cluster UUID because of the following error, will retry in %v: %v", sleepDuration, err)
		select {
		case <-stopCh:
			return
		case <-time.After(sleepDuration):
			continue
		}
	}
}

// ClusterUUIDProvider is an interface used to retieve the cluster UUID generated by Antrea for a
// cluster.
type ClusterUUIDProvider interface {
	Get() uuid.UUID
}

type clusterUUIDProvider struct {
	uuidConfigMapNamespace string
	uuidConfigMapName      string
	k8sClient              clientset.Interface
}

// NewClusterUUIDProvider returns a new object implementing the ClusterUUIDProvider interface.
func NewClusterUUIDProvider(
	uuidConfigMapNamespace string,
	uuidConfigMapName string,
	k8sClient clientset.Interface,
) *clusterUUIDProvider {
	return &clusterUUIDProvider{
		uuidConfigMapNamespace: uuidConfigMapNamespace,
		uuidConfigMapName:      uuidConfigMapName,
		k8sClient:              k8sClient,
	}
}

// Get will retrieve the cluster UUID stored in the antrea-cluster-uuid ConfigMap. In case of error,
// clients are invited to retry as the cluster UUID may not be available yet.
func (p *clusterUUIDProvider) Get() (*uuid.UUID, error) {
	configMap, err := p.k8sClient.CoreV1().ConfigMaps(p.uuidConfigMapNamespace).Get(context.TODO(), p.uuidConfigMapName, metav1.GetOptions{})
	if err != nil {
		return nil, fmt.Errorf("error when getting '%s/%s' ConfigMap: %v", p.uuidConfigMapNamespace, p.uuidConfigMapName, err)
	}
	clusterUUIDStr, ok := configMap.Data[uuidConfigMapKey]
	if !ok || clusterUUIDStr == "" {
		return nil, fmt.Errorf("cluster UUID has not been set yet")
	}
	clusterUUID, err := uuid.Parse(clusterUUIDStr)
	if err != nil {
		return nil, fmt.Errorf("cluster UUID cannot be parsed")
	}
	return &clusterUUID, nil
}
