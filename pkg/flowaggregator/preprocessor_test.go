// Copyright 2024 Antrea Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package flowaggregator

import (
	"net"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	ipfixentities "github.com/vmware/go-ipfix/pkg/entities"
)

func TestPreprocessorProcessMsg(t *testing.T) {
	// For the sake of this test, we can use the same value for IPv4 and IPv6.
	const testTemplateID = 256
	sourceIPv4AddressIE := ipfixentities.NewInfoElement("sourceIPv4Address", 8, 18, 0, 4)
	destinationIPv4AddressIE := ipfixentities.NewInfoElement("destinationIPv4Address", 12, 18, 0, 4)
	sourceIPv6AddressIE := ipfixentities.NewInfoElement("sourceIPv6Address", 27, 19, 0, 16)
	destinationIPv6AddressIE := ipfixentities.NewInfoElement("destinationIPv6Address", 28, 19, 0, 16)
	packetTotalCountIE := ipfixentities.NewInfoElement("packetTotalCount", 86, 4, 0, 8)
	iesIPv4 := []*ipfixentities.InfoElement{sourceIPv4AddressIE, destinationIPv4AddressIE, packetTotalCountIE}
	iesIPv6 := []*ipfixentities.InfoElement{sourceIPv6AddressIE, destinationIPv6AddressIE, packetTotalCountIE}

	iesWithValueIPv4 := []ipfixentities.InfoElementWithValue{
		ipfixentities.NewIPAddressInfoElement(sourceIPv4AddressIE, net.ParseIP("1.1.1.1")),
		ipfixentities.NewIPAddressInfoElement(destinationIPv4AddressIE, net.ParseIP("1.1.2.1")),
	}
	iesWithValueIPv6 := []ipfixentities.InfoElementWithValue{
		ipfixentities.NewIPAddressInfoElement(sourceIPv6AddressIE, net.ParseIP("::1")),
		ipfixentities.NewIPAddressInfoElement(destinationIPv6AddressIE, net.ParseIP("::2")),
	}

	getTestMsg := func(iesWithValue []ipfixentities.InfoElementWithValue) *ipfixentities.Message {
		s, err := ipfixentities.MakeDataSet(testTemplateID, iesWithValue)
		require.NoError(t, err)
		msg := ipfixentities.NewMessage(true)
		msg.AddSet(s)
		return msg
	}

	testIPFamily := func(t *testing.T, iesWithValue []ipfixentities.InfoElementWithValue) {
		require.Len(t, iesWithValue, 2)
		testCases := []struct {
			name                  string
			templateElementsCount int
			msg                   *ipfixentities.Message
			expectedIEsWithValue  []ipfixentities.InfoElementWithValue
		}{
			{
				name:                  "same elements",
				templateElementsCount: 2,
				msg:                   getTestMsg(iesWithValue[:2]),
				expectedIEsWithValue:  iesWithValue,
			},
			{
				name:                  "extra elements",
				templateElementsCount: 1,
				msg:                   getTestMsg(iesWithValue[:2]),
				expectedIEsWithValue:  iesWithValue[:1],
			},
			{
				name:                  "missing elements",
				templateElementsCount: 3,
				msg:                   getTestMsg(iesWithValue[:2]),
				expectedIEsWithValue:  append(iesWithValue, ipfixentities.NewUnsigned64InfoElement(packetTotalCountIE, 0)),
			},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				// Buffered channel with capacity 1 to hold the output record generated by processMsg.
				outCh := make(chan ipfixentities.Record, 1)
				p, err := newPreprocessor(iesIPv4[:tc.templateElementsCount], iesIPv6[:tc.templateElementsCount], nil, outCh)
				require.NoError(t, err)
				p.processMsg(tc.msg)
				var r ipfixentities.Record
				select {
				case r = <-outCh:
				default:
				}
				if tc.expectedIEsWithValue == nil {
					assert.Nil(t, r, "No record expected")
				} else {
					require.NotNil(t, r, "Record was expected")
					assert.Equal(t, tc.expectedIEsWithValue, r.GetOrderedElementList())
				}
			})
		}
	}

	t.Run("ipv4", func(t *testing.T) {
		testIPFamily(t, iesWithValueIPv4)
	})
	t.Run("ipv6", func(t *testing.T) {
		testIPFamily(t, iesWithValueIPv6)
	})
}
